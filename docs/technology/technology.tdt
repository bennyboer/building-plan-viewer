#TITLE# Festlegung der verwendeten Werkzeuge

#H1, numbered=false# Inhalt

#TOC#


#BREAK, type=page#

#H1# Einleitung

Nun, da die Anforderungen festgelegt sind, sind wir in der Lage Entscheidungen über die verwendeten Werkzeuge und Technologien zu treffen, welche bei dem neuen Werkzeug zur Gebäudeplanvisualisierung zum Einsatz kommen sollen.
Im ersten Schritt wollen wir uns um eine Auflistung und Argumentation der verwendeten Technologien kümmern.

Nachdem zum Beispiel die verwendete Programmiersprache festgelegt ist, wird unter anderem eine Bibliothek für das Lesen von CAD-Dateien gesucht.
Die verschiedenen Möglichkeiten werden gesammelt und anschließend verglichen, um die bestmöglichen Voraussetzungen für die weitere Entwicklung der Anwendung zu schaffen.


#BREAK, type=page#

#H1# Auflistung und Argumentation der verwendeten Technologien

Im vorangegangenen Vergleich von CAD-Viewer Programmen haben wir zwei grobe Kategorien von Programmen betrachtet: *web-basierte* und *klassische Desktopanwendungen*.
Beide Varianten können mit denselben Features aufwarten und unterscheiden sich somit lediglich in der Art der Bereitstellung:
Während die web-basierten Anwendungen durch die Eingabe einer URL in der Adresszeile eines Browsers gestartet werden können, müssen die Desktopprogramme lokal auf dem System des Benutzers installiert und gestartet werden.

Anhand der nichtfunktionale Anforderung **NA1** (*Einfache und schnelle Bereitstellung/Installierbarkeit*) tendieren wir daher eher zu einer Webanwendung.
Diese sind tendenziell schneller zu verwenden und leichter zu teilen.
Außerdem stehen geeignete Browser praktisch jedem Endanwender zur Verfügung - selbst auf dem Smartphone.

Im Gegensatz dazu verleitet die nichtfunktionale Anforderung **NA4** (*Ruckelfreie Navigation im Gebäudeplan*) eher dazu, die Gegenseite der klassischen Desktopanwendungen zu befürworten.
Webanwendungen liefern klassischerweise weniger Performance verglichen mit Desktopanwendungen.
Grund dafür ist die Programmiersprache *JavaScript*, welche von den verschiedenen Browserimplementierungen mehr oder weniger schnell interpretiert wird.
Allerdings gab es in den letzten Jahren deutliche Performanceverbesserungen #CITE, 'WebAppMolecular, location=page 576'#.
Beispielsweise gibt es speziell für das Rendering von Visualisierungen mittlerweile Unterstützung durch die vorhandene Grafikhardware des Benutzers, auf welche mit Hilfe der *WebGL* API zugegriffen werden kann #CITE, 'WebAppMolecular, location=page 576'#.

Da mit der zu entwickelnden Anwendung möglichst auch äußerst komplexe und große Gebäudepläne dargestellt werden sollen, ist es sinnvoll ebenso auf der WebGL API aufzusetzen.
Vorhandene JavaScript Bibliotheken wie *three.js* #CITE, 'ThreeJS'# kapseln die WebGL API auf einer höheren Ebene, um diese schnell und einfach zu verwenden.
Das ist für unser Projekt ebenfalls wichtig, da die nichtfunktionale Anforderung **NA2** eine einfache Wartbarkeit fordert.
Die WebGL API ist an OpenGL ES 2.0 angelehnt und daher nur mit dem nötigen Hintergrundwissen zu verwenden #CITE, 'WebGL'#.
Die Bibliothek three.js scheint daher geeignet für das Projekt, um eine spätere gute Wartbarkeit sicherzustellen.

JavaScript ist eine dynamisch typisierte Programmiersprache.
Alternativen wie *TypeScript* von Microsoft hingegen versuchen eine statische Typisierung um JavaScript zu ermöglichen #CITE, 'ToTypeOrNotToType, location=page 758'#.
Es wird oft argumentiert, dass eine statische Typisierung zu einem besseres Verständnis des Programmes, neben anderen Vorteilen, führt #CITE, 'ToTypeOrNotToType, location=page 758'#.
Um die Wartbarkeit unseres Projekts weiter zu erhöhen, soll daher TypeScript als Programmiersprache verwendet werden.

Die Entwicklung einer Webanwendung kann durch die Verwendung eines geeigneten Frameworks vereinfacht werden.
Wir haben uns für das Framework *Angular* #CITE, 'Angular'# entschieden, da dieses bereits alle benötigten Komponenten für eine moderne UI mitliefert #CITE, 'AngularMaterial'# und standardmäßig mit TypeScript zu verwenden ist.

Zusammenfassend soll das Werkzeug zur Gebäudeplanvisualisierung also als **Webanwendung** entstehen.
Diese soll in der Programmiersprache **TypeScript** unter Verwendung des Frameworks **Angular** verfasst werden.
Zusätzlich wird **three.js** zur einfacheren Verwendung der WebGL API verwendet, womit schlussendlich die Gebäudepläne visualisiert werden.


#BREAK, type=page#

#H1# Vergleich von Parserbibliotheken für CAD-Dateien

Mittlerweile haben wir auch die Programmiersprache TypeScript festgelegt.
Bei der Sprache handelt es sich um ein Superscript von JavaScript, welches zum Beispiel ein statisches Typensystem einführt #CITE, 'TypeScript'#.
Das bedeutet auch, dass es sich im Grunde um JavaScript handelt.
Somit können Softwarebibliotheken, welche eigentlich in JavaScript geschrieben worden sind, ohne Probleme verwendet werden.

Wie bereits erwähnt soll das Werkzeug zur Gebäudevisualisierung `*.dxf` Dateien lesen können.
Im JavaScript-Ökosystem sehen wir uns damit mit einer Auswahl an geeigneten Bibliotheken konfrontiert.
Unsere Zielsetzung für dieses Kapitel ist es, die für unsere Zwecke bestmögliche Möglichkeit zu finden.

Als erster Schritt steht eine Internetrecherche auf dem Plan, welche zu einer Auflistung von Parserbibliotheken führen soll.
Bei einer Suche über `npmjs.com` sind die folgenden Bibliotheken aufgetaucht:

- **Dxf-Parser** #CITE, 'DxfParserNpm'#
- **dxf** #CITE, 'DxfNpm'#
- **dxftoobject** #CITE, 'dxftoobjectNpm'#
- **dxf2svg** #CITE, 'dxf2svgNpm'#

Wir wollen diese nach *Performance (Ladegeschwindigkeit)*, *Lizenz*, *Beliebtheit auf `npmjs.com`* (Wöchentliche Downloads #FOOTNOTE, "Jeweils abgerufen am 25.10.2020 um 15:30"#), *Aktualität* und der Güte der *Dokumentation* beurteilen.

Zunächst wird die Performance gemessen, indem wir für jede Alternative dieselbe CAD-Datei lesen.
Das Testprogramm, welches für jeden Messdurchgang durchgeführt wird, befindet sich im #REF, testapp, prefix=Codebeispiel#.

#CODE, '
public static readFile(file: File): void {
	const reader: FileReader = new FileReader();
	reader.onload = async (e) => {
		const dxfContentStr: string | ArrayBuffer = e.target.result;

		console.log("dxf:")
		let timer = window.performance.now();
		const helper = new DXF.Helper(dxfContentStr);
		console.log(helper.parsed);
		console.log(`dxf took ${window.performance.now() - timer}ms`);

		console.log("dxf2svg:");
		timer = window.performance.now();
		console.log(dxf2svg.parseString(dxfContentStr));
		console.log(`dxf2svg took ${window.performance.now() - timer}ms`);

		console.log("dxf2object:");
		timer = window.performance.now();
		await dxftoobject.default(dxfContentStr).then(result => console.log(result));
		console.log(`dxf2object took ${window.performance.now() - timer}ms`);

		console.log("dxf-parser:")
		timer = window.performance.now();
		console.log(new DxfParser().parseSync(dxfContentStr));
		console.log(`dxf-parser took ${window.performance.now() - timer}ms`);
	};
	reader.readAsText(file);
}
', style=manni, language=typescript, label=testapp, caption="Testprogramm zum Messen der Ladegeschwindigkeiten der verschiedenen CAD-Datei Lesebibliotheken."#

Wie aus #REF, perf, prefix=Tabelle# ersichtlich ist, reichen fünf Messungen aus, da die Standardabweichung jeweils sehr gering ist.

#TABLE, '
Messung | **Dxf-Parser** | **dxf** | **dxftoobject** | **dxf2svg**
*1* | 35 | 69 | 936 | 52
*2* | 35 | 40 | 892 | 44
*3* | 45 | 52 | 873 | 56
*4* | 43 | 65 | 933 | 66
*5* | 34 | 61 | 900 | 52
**Durchschnitt** | 38,4 | 57,4 | 906,8 | 54,0
**Standardabweichung** | 4,630334761 | 10,36532682 | 24,27673784 | 7,155417528
', caption="Ladegeschwindigkeitsmessungen der verschiedenen CAD-Datei Lesebibliotheken mit dem Testprogramm - in Millisekunden.", label=perf#

#BREAK, type=page#

In der folgenden #REF, nutzwert, prefix=Tabelle# werden die einzelnen Kriterien für die Bibliotheken bewertet.
Um eine möglichst zutreffende Einschätzung zu erhalten, wird eine Nutzwertanalyse durchgeführt.
Für alle Kriterien außer Lizenz werden die Punkte 1 - 4 vergeben.
Die Lizenz erhält entweder 0 (Nicht in Ordnung) oder 1 (In Ordnung).
Am Ende werden die Punkte, welche sich in der Tabelle neben jeder Einschätzung in Klammern befinden, aufsummiert und die geeigneteste Bibliothek ausgewertet.

#TABLE, '
• | **Dxf-Parser** | **dxf** | **dxftoobject** | **dxf2svg**
Performance | `38,4ms` (4) | `57,4ms` (2) | `906,8ms` (1) | `54,0ms` (3)
Lizenz | MIT (1) | MIT (1) | keine Angabe (0) | MIT (1)
Beliebtheit (wöchentliche Downloads) | 634 (3) | 702 (4) | 11 (1) | 31 (2)
Aktualität (Letztes Update) | 29.11.2019 (2) | 16.07.2020 (4) | 23.12.2019 (3) | 20.03.2019 (1)
Dokumentation | Zufriedenstellend (Quellcode vorhanden) (3) | Umfangreich (Quellcode vorhanden) (4) | Wenig (Quellcode vorhanden) (2) | Wenig bis nicht vorhanden (kein Quellcode vorhanden) (1)
**Summe der Punkte** | 13 | 15 | 7 | 8
', caption="Vergleich der verschiedenen CAD-Datei Parserbibliotheken", label=nutzwert#

Es wird also die Bibliothek **dxf** ausgewählt, da diese die höchste Punktzahl erhalten hat.
Ein Blick in die Tabelle zeigt, dass lediglich die Performance bei dieser Bibliothek geringer ist, als bei *Dxf-Parser* oder *dxf2svg*.
Allerdings handelt es sich hier um einen sehr geringen Unterschied von wenigen Millisekunden, wodurch dieser nicht weiter ins Gewicht fällt.

Somit stehen schlussendlich die verwendeten Werkzeuge für die zu entwickelnde Anwendung für Gebäudevisualisierungen fest und es kann mit der Implementierungsphase begonnen werden.

#BREAK, type=page#

#H1, numbered=false# Literaturverzeichnis

#REFERENCES#
