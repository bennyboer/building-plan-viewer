\subsection{Verwendete Werkzeuge}
\label{subsec:used-tools}

Nun, da die Anforderungen festgelegt sind, sind wir in der Lage Entscheidungen über die verwendeten Werkzeuge und Technologien zu treffen, welche bei dem neuen Werkzeug zur Gebäudeplanvisualisierung zum Einsatz kommen sollen.
Im ersten Schritt wollen wir uns um eine Auflistung und Argumentation der verwendeten Technologien kümmern.

Nachdem zum Beispiel die verwendete Programmiersprache festgelegt ist, wird unter anderem eine Bibliothek für das Lesen von CAD-Dateien gesucht.
Die verschiedenen Möglichkeiten werden gesammelt und anschließend verglichen, um die bestmöglichen Voraussetzungen für die weitere Entwicklung der Anwendung zu schaffen.

\subsubsection{Auflistung und Argumentation der verwendeten Technologien}
\label{subsec:collection-tools}

Im vorangegangenen Vergleich von CAD-Viewer Programmen haben wir zwei grobe Kategorien von Programmen betrachtet: \textit{web-basierte} und \textit{klassische Desktopanwendungen}.
Beide Varianten können mit denselben Features aufwarten und unterscheiden sich somit lediglich in der Art der Bereitstellung:
Während die web-basierten Anwendungen durch die Eingabe einer URL in der Adresszeile eines Browsers gestartet werden können, müssen die Desktopprogramme lokal auf dem System des Benutzers installiert und gestartet werden.

Anhand der nichtfunktionale Anforderung \textbf{NA1} (\textit{Einfache und schnelle Bereitstellung/Installierbarkeit}) tendieren wir daher eher zu einer Webanwendung.
Diese sind tendenziell schneller zu verwenden und leichter zu teilen.
Außerdem stehen geeignete Browser praktisch jedem Endanwender zur Verfügung - selbst auf dem Smartphone.

Im Gegensatz dazu verleitet die nichtfunktionale Anforderung \textbf{NA4} (\textit{Ruckelfreie Navigation im Gebäudeplan}) eher dazu, die Gegenseite der klassischen Desktopanwendungen zu befürworten.
Webanwendungen sind klassischerweise weniger performant verglichen mit Desktopanwendungen.
Grund dafür ist die Programmiersprache \textit{JavaScript}, welche von den verschiedenen Browserimplementierungen mehr oder weniger schnell interpretiert wird.
Allerdings gab es in den letzten Jahren deutliche Performanceverbesserungen~\cite{WebAppMolecular}.
Beispielsweise gibt es speziell für das Rendering von Visualisierungen mittlerweile Unterstützung durch die vorhandene Grafikhardware des Benutzers, auf welche mit Hilfe der \textit{WebGL} API zugegriffen werden kann~\cite{WebAppMolecular}.

Da mit der zu entwickelnden Anwendung möglichst auch äußerst komplexe und große Gebäudepläne dargestellt werden sollen, ist es sinnvoll ebenso auf der WebGL API aufzusetzen.
Vorhandene JavaScript Bibliotheken wie \textit{three.js}~\cite{ThreeJS} kapseln die WebGL API auf einer höheren Ebene, um diese schnell und einfach zu verwenden.
Das ist für unser Projekt ebenfalls wichtig, da die nichtfunktionale Anforderung \textbf{NA2} eine einfache Wartbarkeit fordert.
Die WebGL API ist an OpenGL ES 2.0 angelehnt und daher nur mit dem nötigen Hintergrundwissen zu verwenden~\cite{WebGL}.
Die Bibliothek three.js scheint daher geeignet für das Projekt, um eine spätere gute Wartbarkeit sicherzustellen.

JavaScript ist eine dynamisch typisierte Programmiersprache.
Alternativen wie \textit{TypeScript} von Microsoft hingegen versuchen eine statische Typisierung um JavaScript zu ermöglichen~\cite{ToTypeOrNotToType}.
Es wird oft argumentiert, dass eine statische Typisierung zu einem besseres Verständnis des Programmes, neben anderen Vorteilen, führt~\cite{ToTypeOrNotToType}.
Um die Wartbarkeit unseres Projekts weiter zu erhöhen, soll daher TypeScript als Programmiersprache verwendet werden.

Die Entwicklung einer Webanwendung kann durch die Verwendung eines geeigneten Frameworks vereinfacht werden.
Wir haben uns für das Framework \textit{Angular}~\cite{Angular} entschieden, da dieses bereits alle benötigten Komponenten für eine moderne UI mitliefert~\cite{AngularMaterial} und standardmäßig mit TypeScript zu verwenden ist.

Eine Webanwendung benötigt einen HTTP-Server, welche diese bereitstellt.
Ebenfalls soll die Anwendung nach Anforderung A5 eine REST-API bereitstellen, über welche die Raummappings (Clusteringergebnisse) und CAD Dateien hochgeladen werden können.
Für die REST-Schnittstelle ist ebenfalls ein \glqq{}Backend\grqq{} nötig.
Wir verwenden das \textit{Spring Framework} zur Entwicklung einer solchen Serveranwendung, da dort bereits zahlreiche Bibliotheken zur Erweiterung existieren~\cite{SpringFramework}.
So kann die Serveranwendung einerseits als HTTP Server fungieren und die Webanwendung bereitstellen, andererseits eine REST-API anbieten.

Zusammenfassend soll das Werkzeug zur Gebäudeplanvisualisierung also als \textbf{Webanwendung} entstehen.
Diese soll in der Programmiersprache \textbf{TypeScript} unter Verwendung des Frameworks \textbf{Angular} verfasst werden.
Zusätzlich wird \textbf{three.js} zur einfacheren Verwendung der WebGL API verwendet, womit schlussendlich die Gebäudepläne visualisiert werden.
Die Client-Anwendung soll von einer zusätzlichen Serveranwendung, welche mit Hilfe des Spring Frameworks implementiert wird, bereitgestellt werden.

\subsubsection{Vergleich von Parserbibliotheken für CAD-Dateien}
\label{subsubsec:comparison-parser-libs}

Mittlerweile haben wir uns für die Programmiersprache TypeScript entschieden.
Bei der Sprache handelt es sich um ein sogenanntes \glqq{}Superscript\grqq{} von JavaScript, welches unter anderem ein statisches Typensystem einführt~\cite{TypeScript}.
Das bedeutet auch, dass es sich im Grunde um JavaScript handelt.
Somit können Softwarebibliotheken, welche eigentlich in JavaScript geschrieben worden sind, ohne Probleme verwendet werden.

Wie bereits erwähnt soll das Werkzeug zur Gebäudevisualisierung \texttt{*.dxf} Dateien lesen können.
Im JavaScript-Ökosystem sehen wir uns daher mit einer Auswahl an geeigneten Bibliotheken konfrontiert.
Unsere Zielsetzung für dieses Kapitel ist es, die für unsere Zwecke beste Möglichkeit zu finden.

Als erster Schritt steht eine Internetrecherche auf dem Plan, welche zu einer Auflistung von Parserbibliotheken führen soll.
Bei einer Suche über https://www.npmjs.com/ sind die folgenden Bibliotheken aufgetaucht:

\begin{enumerate}
    \item \textbf{Dxf-Parser}~\cite{DxfParserNpm}
    \item \textbf{dxf}~\cite{DxfNpm}
    \item \textbf{dxftoobject}~\cite{dxftoobjectNpm}
    \item \textbf{dxf2svg}~\cite{dxf2svgNpm}
\end{enumerate}

Wir wollen diese nach \textit{Performance (Ladegeschwindigkeit)}, \textit{Lizenz}, \textit{Beliebtheit auf npmjs.com} (Wöchentliche Downloads (Jeweils abgerufen am 25.10.2020 um 15:30), \textit{Aktualität} und der Güte der \textit{Dokumentation} beurteilen.
Das Testprogramm, welches für jeden Messdurchgang durchgeführt wird, befindet sich im Codebeispiel~\ref{code:test-code}.

\begin{lstlisting}[language=Java,breaklines,basicstyle=\ttfamily\scriptsize,label=code:test-code,caption={Testprogramm, welches für jeden Messdurchgang durchgeführt wird. Dient zur Bestimmung der Bibliothekenlaufzeit.}]
public static readFile(file: File): void {
	const reader: FileReader = new FileReader();
	reader.onload = async (e) => {
		const dxfContentStr: string | ArrayBuffer = e.target.result;

		console.log("dxf:")
		let timer = window.performance.now();
		const helper = new DXF.Helper(dxfContentStr);
		console.log(helper.parsed);
		console.log(`dxf took ${window.performance.now() - timer}ms`);

		console.log("dxf2svg:");
		timer = window.performance.now();
		console.log(dxf2svg.parseString(dxfContentStr));
		console.log(`dxf2svg took ${window.performance.now() - timer}ms`);

		console.log("dxf2object:");
		timer = window.performance.now();
		await dxftoobject.default(dxfContentStr).then(result => console.log(result));
		console.log(`dxf2object took ${window.performance.now() - timer}ms`);

		console.log("dxf-parser:")
		timer = window.performance.now();
		console.log(new DxfParser().parseSync(dxfContentStr));
		console.log(`dxf-parser took ${window.performance.now() - timer}ms`);
	};
	reader.readAsText(file);
}
\end{lstlisting}

Wie aus Tabelle~\ref{table:test-results} ersichtlich ist, reichen fünf Messungen aus, da die Standardabweichung jeweils sehr gering ist.

\begin{center}
    \bottomcaption{Ladegeschwindigkeitsmessungen der verschiedenen CAD-Datei Lesebibliotheken mit dem Testprogramm - in Millisekunden.}
    \small
    \begin{supertabular}{ p{1.8cm}|p{1.4cm}|p{1cm}|p{1.5cm}|p{1.2cm} }
        \label{table:test-results}
        Messung & \textbf{Dxf-Parser} & \textbf{dxf} & \textbf{dxftoobject} & \textbf{dxf2svg} \\
        \hline
        \textit{1} & 35 & 69 & 936 & 52 \\
        \textit{2} & 35 & 40 & 892 & 44 \\
        \textit{3} & 45 & 52 & 873 & 56 \\
        \textit{4} & 43 & 65 & 933 & 66 \\
        \textit{5} & 34 & 61 & 900 & 52 \\
        \textbf{Durchschnitt} & 38,4 & 57,4 & 906,8 & 54,0 \\
        \textbf{Std. Abw.} & 4,6303 & 10,3653 & 24,2767 & 7,1554 \\
    \end{supertabular}
\end{center}

In der folgenden Tabelle~\ref{table:nutzwert} werden die einzelnen Kriterien für die Bibliotheken bewertet.
Um eine möglichst zutreffende Einschätzung zu erhalten, wird eine Nutzwertanalyse durchgeführt.
Für alle Kriterien außer Lizenz werden die Punkte 1 - 4 vergeben.
Die Lizenz erhält entweder 0 (Nicht in Ordnung) oder 1 (In Ordnung).
Am Ende werden die Punkte, welche sich in der Tabelle neben jeder Einschätzung in Klammern befinden, aufsummiert und die geeigneteste Bibliothek ausgewertet.

\begin{center}
    \bottomcaption{Vergleich der verschiedenen CAD-Datei Parserbibliotheken.}
    \scriptsize
    \begin{supertabular}{ p{1.4cm}|p{1.6cm}|p{1.5cm}|p{1.3cm}|p{1.3cm} }
        \label{table:nutzwert}
        & \textbf{Dxf-Parser} & \textbf{dxf} & \textbf{dxftoobject} & \textbf{dxf2svg} \\
        \hline
        Performance & 38,4ms (4) & 57,4ms (2) & 906,8ms (1) & 54,0ms (3) \\
        Lizenz & MIT (1) & MIT (1) & keine Angabe (0) & MIT (1) \\
        Beliebtheit (wöchentliche Downloads) & 634 (3) & 702 (4) & 11 (1) & 31 (2) \\
        Aktualität (Letztes Update) & 29.11.2019 (2) & 16.07.2020 (4) & 23.12.2019 (3) & 20.03.2019 (1) \\
        Dokumentat. & Zufriedenstellend (Quellcode vorhanden) (3) & Umfangreich (Quellcode vorhanden) (4) & Wenig (Quellcode vorhanden) (2) & Wenig bis nicht vorhanden (kein Quellcode vorhanden) (1) \\
        \hline
        \textbf{Summe der Punkte} & 13 & 15 & 7 & 8 \\
    \end{supertabular}
\end{center}

Es wird also die Bibliothek \textbf{dxf} ausgewählt, da diese die höchste Punktzahl erhalten hat.
Ein Blick in die Tabelle zeigt, dass lediglich die Performance bei dieser Bibliothek geringer ist, als bei \textit{Dxf-Parser} oder \textit{dxf2svg}.
Allerdings handelt es sich hier um einen sehr geringen Unterschied von wenigen Millisekunden, wodurch dieser nicht weiter ins Gewicht fällt.

Somit stehen schlussendlich die verwendeten Werkzeuge für die zu entwickelnde Anwendung für Gebäudevisualisierungen fest.

